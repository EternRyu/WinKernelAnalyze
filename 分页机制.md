### 常见的分页
|分页模式|常见系统|位|
|---|---|---|
|10-10-12分页|Windows xp|x86|
|2-9-9-12分页|Windows xp|x86|
|9-9-9-9-12分页|Windows 7以上|x64|

分页(Paging)指的是将线性地址（linear address）转换为物理地址（physical address）的机制，该转换过程是在硬件中完成的，处理器通过设置CR0寄存器中的PG位设置分页机制，当CR0.PG=0时，未开启分页机制，处理器直接把线性地址当成物理地址访问物理内存，当CR0.PG=1时，开启分页机制，处理器只能通过线性地址访问物理内存.

详情见 Intel或AMD白皮书

# 10-10-12分页

物理地址的计算方式
假设某一个数据的线性地址为 0x000B0C40

将他拆分成2进制，并按照10-10-12来分

`00 0000 0000 | 00 1011 0000 | 1100 0010 0000`

转换为16进制为

` 0 | B0 | C40`

地址转换成四字节，前两级都是地址表，因此需要乘以*4

` 0 * 4| B0 * 4 | C40`

`0 | 2C0 | C40`

这就是所要用到的页表偏移

每个进程都有一个DirBase值，即CR3的值，CR3寄存器指向的是一个页，称为页目录表（PDT）

```
CR3->页目录表PDT->页表PTT->物理地址
页目录表（PDT） 内存放的是页目录表项（PDE）
页目录表项（PDE）指向 页表（PTT）
页表（PTT）内存放 页表项（PTE）
页表项（PTE）指向的地址才是真正的物理地址
```
这个页的大小在winodws 32位操作系统中
分页的粒度一般是4KB,还有一种大页（4MB）
所以一个页表大小也是4KB,页表的每个成员也是占有4个字节的地址

[源  Intel 4-10 Vol. 3A\ AMD 24593—Rev. 3.42—March 2024]

![alt text](ImageFile\1010124KByte.png)

`PDE PTE的0-11位为属性位计算时去掉，即16进制最后三位`
![alt text](ImageFile\PDE4Kbyte.png)
![alt text](ImageFile\4-KbytePTE.png)
 

>P位</br>
有效位。两个P位都为1时该页有效，只要其中一个P位为0时该页无效。</br>
>
>R/W位</br>
读写位，两者的P位都为1时代表该页内存可读可写，只要有一个为0代表只读不可写。（对于非VT而言，一块内存申请出来，它必然是可读的。）1=RWE   0=RE</br>
>
>U/S位</br>
特权等级位，都为0时，特权用户可读写，都为1时，普通用户可读写 ring0  ring1 ring2 ring3</br>
>
>PS位</br>
仅对PDE有意义，PaseSize位，页大小，当PS位为0时，为4KB小页</br>
>
>A位</br>
Access 是否被访问过位，访问过就全部置1，否则为0。 哪怕是一个字节的地址访问也会将其对应的PDE PTE的A位置1.</br>
>
>D位</br>
Dirty 脏位，是否被写过位。逻辑与A位相同。</br>
>
>G位</br>
>全局页，当CR3发生改变后CPU将切换TLB，若G位为1，则该页在CR3发生切换时，TLB中的数据将不被刷新。</br>
>
>PWT位</br>
>页面级直写式;间接确定线性期间访问页目录所使用的内存类型地址转换</br>
>
>PCD位</br>
>禁用页面级缓存；间接确定线性期间访问页目录所使用的内存类型地址转换</br>
>
>PAT位</br>
>如果支持PAT，则间接确定用于访问此引用的4mbyte页面的内存类型条目;否则，保留（必须为0）1</br>



通过windbg的 "!process 0 0" 指令，查看每个进程的CR3值(DirBase)
```
计算示例
DirBase=0x1491c000

PDE = 0x1491c000+0

kd> !dd 1491c000
　　　　#1491c000 14828067 14833067 14883067 00000000
　　　　#1491c010 14807067 00000000 00000000 00000000

内存地址后三个字节为属性，因此我们查出地址后自动将16进制的后三位变为零即可
PTE= 14828000+0x2C0

kd> !dd 14828000+2c0
　　　　#148282c0 14a05067 14998067 14a09067 149fa067
　　　　#148282d0 1497b067 14a6c067 149ed067 1a57b067

PA=14a05000+0xC40
kd> !db 14a05000+c40
　　　　#14a05c40 68 00 65 00 6c 00 6c 00-6f 00 20 00 77 00 6f 00 h.e.l.l.o. .w.o.
　　　　#14a05c50 72 00 6c 00 64 00 21 00-21 00 21 00 00 00 00 00 r.l.d.!.!.!....
```

# 2-9-9-12分页
32位cpu下提高物理地址的寻址范围引入了2-9-9-12的分页模式又被叫做为PAE物理地址扩展

长模式页面转换需要使用物理地址扩展（PAE）。</br>
启用长模式前，必须通过设置CR4使能PAE。PAE设置1</br>


[源 Intel 4-16 Vol. 3A\AMD 24593—Rev. 3.42—March 2024]
![alt text](ImageFile\299124Kbyte.png)

![alt text](ImageFile\PAEPagingLegacy-Mode.png)

假设2-9-9-12分页模式下取得变量的虚拟地址为0x0104FE58

拆分：

`00 | 00 0001 000 | 0 0100 1111 | 1110 0101 1000`

`0x0 | 0x8 | 0x4F | 0xE58`

一个PAE占8字节 所以偏移为：

`0x0*8 | 0x8*8 | 0x4F*8 | 0xE58`

之后类似的通过DirBase逐级找到相应值并抹除后3位属性位后加上偏移，直到找到PV(物理地址)即可

# 9-9-9-9-12分页
64位系统下的最大寻址范围为64位但实际上，CPU只使用了其中的48位用于寻址，用`9-9-9-9-12分页模式`

>在Intel\AMD开发手册中，将这四级页表分别称为PML4E、PDPTE、PDE、PTE<br>
微软的命名方式略有不同，如WinDbg将这四级页表分别称为PXE、PPE、PDE、PTE

[源 Intel 4-22 Vol. 3A\AMD 24593—Rev. 3.42—March 2024]
![alt text](ImageFile\9999124KByte.png)

![alt text](ImageFile\4LevelPaging.png)

![alt text](ImageFile\4KbytePTELongMode.png)

计算方式：
假设某个变量的虚拟地址为`0x21BABF52920`<br>
将线性地址的二进制位拆分成9-9-9-9-12五组 应为只用到48位则不足48位的补全到48位<br>
`0000 0010 0 | 001 1011 10 | 10 1011 111 | 1 0101 0010 | 1001 0010 0000`<br>
转换为16进制为：<br>
`0x4 | 0x6e | 0x15F | 0x152 | 0x920`<br>
乘上每项大小 8 bytes 即为相应表下的偏移量:<br>
`0x4*8 | 0x6e*8 | 0x15F*8 | 0x152*8 | 0x920`<br>
之后用DirBase开始逐项查找即可找到PV(物理地址)

## Level 5 分页
除了4级分页外还有5级分页为9-9-9-9-9-12分页


## 页表基址
在x86系统中，页表基址是固定的，位于0xC0000000 ,页目录表基址 0xC0300000<br>

在x64系统中，页表基址不再是固定的值，而是每次系统启动后随机生成的