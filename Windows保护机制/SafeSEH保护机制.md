# SafeSEH 机制作用

异常处理函数的调用是通过RtlDispatchException()函数处理实现的<br>
SafeSEH机制也是从这里开始的

检查异常处理链是否位于当前程序栈中，如果不在当前栈中，将终止异常处理函数的调用。
检查异常处理函数指针是否位于当前程序栈中，如果指向当前栈中，程序将终止异常处理函数的调用。
在通过前两项检查之后，将通过一个全新的函数RtlIsValidHandler()函数来对异常处理函数的有效性进行验证。

### `RtlIsValidHandle`流程分析
```
（1）判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH 标识。如果设置了这个标识，这个程序内的异常会被忽略。所以当这个标志被设置时，函数直接返回校验失败。
（2）检测程序是否包含安全S.E.H 表。如果程序包含安全S.E.H 表，则将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。
（3）判断程序是否设置ILonly 标识。如果设置了这个标识，说明该程序只包含.NET 编译人中间语言，函数直接返回校验失败。
（4）判断异常处理函数地址是否位于不可执行页（non-executable page）上。当异常处理函数地址位于不可执行页上时，校验函数将检测DEP 是否开启，如果系统未开启DEP 则返回校验成功，否则程序抛出访问违例的异常。
```


### SafeSEH的缺陷
利用S.E.H 的终极特权！这种安全校验存在一个严重的缺陷——如果S.E.H 中的异常函数指针指向堆区，即使安全校验发现了S.E.H 已经不可信，仍然会调用其已被修改过的异常处理函数，因此只要将shellcode 布置到堆区就可以直接跳转执行！


### 绕过方式

```
1.攻击返回地址绕过
2.虚函数绕过
3.从堆中绕过 ： shellcode布置在堆中 ，SEH处理函数指向这个地址即可
4.利用未启用SafeSEH模块绕过 ： 可以把这个模块的指令作为跳板，去执行shellcode
5.加载模块之外的地址绕过 ：内存中有一些Map类型的映射文件，在这些文件中找到跳板指令覆盖SEH处理函数地址即可绕过
6.利用未启用SafeSEH的控件，且控件包含溢出漏洞可以被触发（IE浏览器控件）
```