# GS保护机制
内存保护机制,针对栈溢出，做的保护措施：GS

检测到返回地址是否被覆盖，在IDA中被称为Security Cookie<br>
每个函数增加一些额外的数据和操作，用于检测栈溢出。<br>
在函数调用时，会在返回地址和EBP之前压入一个额外的Security Cookie。系统会比较栈中的这个值和原先存放在.data中的值做一个比较。如果两者不吻合，则栈中发生了溢出<br>
流程：
```
1.取出.data节的第一个双字，作为Cookie的种子，或称为原始Cookie
2.将Cookie种子与esp异或
3.将异或后的值存入canary的地址
4.在函数返回之前，进行这个过程的逆过程
```

并不是对所有的函数都应用GS，以下情况不会应用GS
```
函数不包含缓冲区
函数使用无保护的关键字标记
函数在第一个语句中包含内嵌汇编代码
缓冲区不是8字节类型且大小不大于4个字节
引入#pragma strict_gs_check(on)可以对任意类型的函数添加Security Cookie。
```

Visual Studio 2005后增加`变量联排`

```
将字符串变量移动到栈帧的高位置，防止字符串溢出破坏其他局部变量。
将指针参数和字符串参数复制到内存低地址中，防止被破坏
系统以.data节的第一个双字节作为cookie的种子
每次cookie的种子都不同
在栈帧初始化以后用ESP异或种子，作为当前函数的cookie，以此作为不同函数之间的区别
在函数返回前，用ESP还原出cookie种子
```

### 缺点
```
难以防御基于函数指针，虚函数的攻击
难以防御异常处理的攻击
只防御栈，对堆无能为力
```


## GS的绕过方式

攻击未启用GS的函数

覆盖虚函数绕过GS

攻击异常处理绕过GS

同时替换栈和.data中的Cookie绕过GS

### 不启用GS保护的情况
函数不包含缓冲区
函数被定义为具有变量参数列表.
函数使用无保护的关键字标记.
函数在第一个语句中包含内嵌汇编代码.
缓冲区不是8字节类型且大小不大于4个字节。
